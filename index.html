<html><head><meta content="chrome=1" http-equiv="X-UA-Compatible" /><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport" /><title>purnam</title><style>body {
  padding:50px;
  font:14px/1.5 Helvetica, Arial, sans-serif;
  color:#777;
  font-weight:300;
}

h1, h2, h3, h4, h5, h6 {
  color:#222;
  margin:0 0 20px;
}

p, ul, ol, table, pre, dl {
  margin:0 0 20px;
}

h1, h2, h3 {
  line-height:1.1;
}

h1 {
  font-size:28px;
}

h2 {
  color:#393939;
}

h4, h5, h6 {
  color:#494949;
  margin:0;
}

header h4{
  margin: 10 0 0 0px;
}

a {
  color:#39c;
  font-weight:400;
  text-decoration:none;
}

a small {
  font-size:11px;
  color:#777;
  margin-top:-0.6em;
  display:block;
}

.wrapper {
  width:860px;
  margin:0 auto;
}

.figure div.img {
  text-align: center;
  border-radius: 5px;
  border: 1px solid #ddd;
  padding: 10px;
}

blockquote {
  border-left:1px solid #e5e5e5;
  margin:0;
  padding:0 0 0 20px;
  font-style:italic;
}

code, pre {
  font-family:Monaco, Bitstream Vera Sans Mono, Lucida Console, Terminal;
  color:#333;
  font-size:12px;
}

pre {
  padding:8px 15px;
  background: #f8f8f8;  
  border-radius:5px;
  border:1px solid #e5e5e5;
  overflow-x: auto;
}

table {
  width:100%;
  border-collapse:collapse;
}

th, td {
  text-align:left;
  padding:5px 10px;
  border-bottom:1px solid #e5e5e5;
}

dt {
  color:#444;
  font-weight:700;
}

th {
  color:#444;
}

img {
  max-width:100%;
}

header {
  width:270px;
  float:left;
  /*position:fixed;*/
}

header ul {
  list-style:none;
  height:40px;
  
  padding:0;
  
  background: #eee;
  background: -moz-linear-gradient(top, #f8f8f8 0%, #dddddd 100%);
  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#dddddd));
  background: -webkit-linear-gradient(top, #f8f8f8 0%,#dddddd 100%);
  background: -o-linear-gradient(top, #f8f8f8 0%,#dddddd 100%);
  background: -ms-linear-gradient(top, #f8f8f8 0%,#dddddd 100%);
  background: linear-gradient(top, #f8f8f8 0%,#dddddd 100%);
  
  border-radius:5px;
  border:1px solid #d2d2d2;
  box-shadow:inset #fff 0 1px 0, inset rgba(0,0,0,0.03) 0 -1px 0;
  width:270px;
}

header li {
  width:89px;
  float:left;
  border-right:1px solid #d2d2d2;
  height:40px;
}

header ul a {
  line-height:1;
  font-size:11px;
  color:#999;
  display:block;
  text-align:center;
  padding-top:6px;
  height:40px;
}

strong {
  font-weight:700;
}

header ul li + li {
  width:88px;
  border-left:1px solid #fff;
}

header ul li + li + li {
  border-right:none;
  width:89px;
}

header ul a strong {
  font-size:14px;
  display:block;
  color:#222;
}

section {
  width: 60%;
  float:right;
  padding-bottom:50px;
  padding-right: 10%;
}

small {
  font-size:11px;
}

hr {
  border:0;
  background:#e5e5e5;
  height:1px;
  margin:0 0 20px;
}

footer {
  width:270px;
  float:left;
  position:fixed;
  bottom:50px;
}

header div.heading {
  display:none;
}


@media print, screen and (max-width: 960px) {
  
  div.wrapper {
    width:auto;
    margin:0;
  }
  
  header, section, footer {
    float:none;
    position:static;
    width:auto;
  }
  
  header div.heading {
    display:block;
  }
    
  section div.heading {
    display:none;
  }
  
  section {
    border:1px solid #e5e5e5;
    border-width:1px 0;
    padding:20px 0;
    margin:0 0 20px;
  }
  
  header a small {
    display:inline;
  }
  
  header ul {
    position:absolute;
    right:50px;
    top:52px;
  }
}

@media print, screen and (max-width: 720px) {
  body {
    word-wrap:break-word;
  }
  
  header {
    padding:0;
  }
  
  header ul, header p.view {
    position:static;
  }
  
  pre, code {
    word-wrap:normal;
  }
}

@media print, screen and (max-width: 480px) {
  body {
    padding:15px;
  }
  
  header ul {
    display:none;
  }
}

@media print {
  body {
    padding:0.4in;
    font-size:12pt;
    color:#444;
  }
}


.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold; } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kn { font-weight: bold } /* Keyword.Namespace */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */

.type-csharp .highlight .k { color: #0000FF }
.type-csharp .highlight .kt { color: #0000FF }
.type-csharp .highlight .nf { color: #000000; font-weight: normal }
.type-csharp .highlight .nc { color: #2B91AF }
.type-csharp .highlight .nn { color: #000000 }
.type-csharp .highlight .s { color: #A31515 }
.type-csharp .highlight .sc { color: #A31515 }


</style></head><body><header><div class="heading"><h1>purnam</h1><h3>Language extensions for clojurescript</h3><hr /><div class="info"><h5>Author: Chris Zheng<b>&nbsp;&nbsp;<a href="mailto:z@caudate.me">(z@caudate.me)</a></b></h5><h5>Library: v0.5.1</h5><h5>Date: 09 October 2014</h5><h5>Website: <a href="http://www.github.com/purnam/purnam">http://www.github.com/purnam/purnam</a></h5><h5>Generated By: <a href="http://www.github.com/zcaudate/lein-midje-doc">MidjeDoc</a></h5></div><br /><hr /></div><h4><a href="#installation">1 &nbsp; Installation</a></h4><h4><a href="#motivation">2 &nbsp; Motivation</a></h4><h4><a href="#quickstart">3 &nbsp; Quickstart</a></h4><h5>&nbsp;&nbsp;<i><a href="#native-datastructures">3.1 &nbsp; Native Datastructures</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#native-functions">3.2 &nbsp; Native Functions</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#native-protocols">3.3 &nbsp; Native Protocols</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#dsl-for-testing">3.4 &nbsp; DSL for Testing</a></i></h5><h4><a href="#purnam-native-functions">4 &nbsp; purnam.native.functions</a></h4><h5>&nbsp;&nbsp;<i><a href="#init-native-functions">4.1 &nbsp; init</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#js-lookup">4.2 &nbsp; js-lookup</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#js-equals">4.3 &nbsp; js-equals</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#js-assoc">4.4 &nbsp; js-assoc</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#js-dissoc">4.5 &nbsp; js-dissoc</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#js-empty">4.6 &nbsp; js-empty</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#js-merge">4.7 &nbsp; js-merge</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#js-merge-nil">4.8 &nbsp; js-merge-nil</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#js-copy">4.9 &nbsp; js-copy</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#js-deep-copy">4.10 &nbsp; js-deep-copy</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#js-replace">4.11 &nbsp; js-replace</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#js-map">4.12 &nbsp; js-map</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#js-concat">4.13 &nbsp; js-concat</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#js-mapcat">4.14 &nbsp; js-mapcat</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#js-arities">4.15 &nbsp; js-arities</a></i></h5><h4><a href="#purnam-native">5 &nbsp; purnam.native</a></h4><h5>&nbsp;&nbsp;<i><a href="#init-native">5.1 &nbsp; init</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#seq-protocol">5.2 &nbsp; seq protocol</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#transient-protocol">5.3 &nbsp; transient protocol</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#collection-protocol">5.4 &nbsp; collection protocol</a></i></h5><h4><a href="#purnam-core">6 &nbsp; purnam.core</a></h4><h5>&nbsp;&nbsp;<i><a href="#init-core">6.1 &nbsp; init</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#obj">6.2 &nbsp; obj</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#arr">6.3 &nbsp; arr</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#getter">6.4 &nbsp; getter - ?</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#setter">6.5 &nbsp; setter - !</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#call">6.6 &nbsp; call - ?></a></i></h5><h5>&nbsp;&nbsp;<i><a href="#call-on">6.7 &nbsp; call on - !></a></i></h5><h5>&nbsp;&nbsp;<i><a href="#this">6.8 &nbsp; this</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#self">6.9 &nbsp; self</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#dot-defn">6.10 &nbsp; def.n</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#dot-fn">6.11 &nbsp; f.n</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#dot-do">6.12 &nbsp; do.n</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#raw">6.13 &nbsp; raw forms</a></i></h5><h4><a href="#purnam-test">7 &nbsp; purnam.test</a></h4><h5>&nbsp;&nbsp;<i><a href="#init">7.1 &nbsp; init</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#describe">7.2 &nbsp; describe</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#async">7.3 &nbsp; async</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#fact">7.4 &nbsp; fact</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#facts">7.5 &nbsp; facts</a></i></h5><h4><a href="#end-notes">8 &nbsp; End Notes</a></h4><br /></header><section><div class="heading"><h1>purnam</h1><h3>Language extensions for clojurescript</h3><hr /><div class="info"><h5>Author: Chris Zheng<b>&nbsp;&nbsp;<a href="mailto:z@caudate.me">(z@caudate.me)</a></b></h5><h5>Library: v0.5.1</h5><h5>Date: 09 October 2014</h5><h5>Website: <a href="http://www.github.com/purnam/purnam">http://www.github.com/purnam/purnam</a></h5><h5>Generated By: <a href="http://www.github.com/zcaudate/lein-midje-doc">MidjeDoc</a></h5></div><br /><hr /></div><div><a name="installation"></a><h2><b>1 &nbsp;&nbsp; Installation</b></h2></div><div><p>Add to <code>project.clj</code> dependencies: </p><p><code>&#91;im.chit/purnam </code>&quot;<code>0.5.1</code>&quot;<code>&#93;</code></p></div><div><p>Looking for documentation for <code>purnam.angular</code>? The library has been renamed and moved to a new home at <a href='http://purnam.github.io/gyr'>http://purnam.github.io/gyr</a></p></div><div><a name="motivation"></a><h2><b>2 &nbsp;&nbsp; Motivation</b></h2></div><div><p><a href='https://www.github.com/purnam/purnam'>purnam</a> is a <em>clojurescript</em> library designed to provide better clojurescript/javascript interop, testing and documentation tools to the programmer. Current projects requiring interface with external javascript libraries will greatly benefit from <code>purnam</code> language extensions. 'Pure' clojure/clojurescript libraries will also benefit with its unit-testing and documentation workflows. The library was written to solve a number of pain points that are experienced in clojurescript development:</p><h4>Better JS Interop</h4><p>The first pain point was having to deal with the clojurish <code>&#40;.dot syntax&#41;</code> for javascript interop as well as a lack of functionality when working with native js objects. This made it especially hard for working with any external js library. <code>purnam</code> offers:</p><ul><li><a href='#purnam-native-functions'>purnam.native.functions</a> - functions for native objects and arrays</li><li><a href='#purnam-native'>purnam.native</a> - clojure protocols for native objects and arrays</li><li><a href='#purnam-js'>purnam.core</a> - a set of macros allowing javascript-like syntax for better interop</li></ul><h4>In-Browser Testing</h4><p>The second pain point was the lack of testing tools that worked with the browser. I wanted something with more debugging power and so unit testing is integrated with the <a href='http://karma-runner.github.io/'>karma</a> test runner using two different test styles:</p><ul><li><a href='#purnam-test'>purnam.test</a> - testing using <a href='http://pivotal.github.io/jasmine/'>jasmine</a> flavored or <a href='https://github.com/marick/Midje'>midje</a> flavored syntax.</li></ul><h4>Integrated Documentation</h4><p>The third pain point was the lack of documentation tools for clojurescript as well as clojure. <code>purnam</code> is compatible with <a href='https://www.github.com/zcaudate/lein-midje-doc'>midje-doc</a> so that the integrated testing and documentation <a href='http://z.caudate.me/combining-tests-and-documentation/'>workflow</a> can be also used in clojurescript.</p></div><div><a name="quickstart"></a><h2><b>3 &nbsp;&nbsp; Quickstart</b></h2></div><div><p>The quickest way to start is to look at some sample projects:</p><ul><li><a href='https://github.com/purnam/example.purnam.game'>Crafty.js Example</a> uses <a href='#purnam-js'><code>purnam.core</code></a></li><li><a href='https://github.com/purnam/example.purnam.test'>Karma Testing Example</a> uses <a href='#purnam-test'><code>purnam.test</code></a> and <a href='#purnam-test-sweet'><code>purnam.test.sweet</code></a></li></ul></div><div><a name="native-datastructures"></a><h3>3.1 &nbsp;&nbsp; Native Datastructures</h3></div><div><p><a href='#obj'>obj</a>, <a href='#arr'>arr</a> and <a href='#raw'>def&#42;</a> in the <a href='#purnam-core'>purnam.core</a> namespace allow nested objects and arrays to be constructed. The examples below show equivalent objects in javascript and clojurescript</p></div><div><a name="js-object"></a><h4><i>e.3.1  &nbsp;-&nbsp; js object</i></h4><div class="highlight"><pre><span class="kd">var</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span><span class="nx">ids</span><span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="nx">account</span><span class="o">:</span> <span class="p">{</span><span class="nx">username</span><span class="o">:</span> <span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="nx">password</span><span class="o">:</span> <span class="s1">&#39;pass&#39;</span><span class="p">}}</span>
</pre></div>
</div><div><a name="cljs-object---obj"></a><h4><i>e.3.2  &nbsp;-&nbsp; cljs object - obj</i></h4><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">user</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:ids</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="ss">:account</span> <span class="p">{</span><span class="ss">:username</span> <span class="s">&quot;user&quot;</span> <span class="ss">:password</span> <span class="s">&quot;pass&quot;</span><span class="p">}))</span>
</pre></div>
</div><div><a name="cljs-object---def*"></a><h4><i>e.3.3  &nbsp;-&nbsp; cljs object - def*</i></h4><div class="highlight"><pre><span class="p">(</span><span class="nf">def*</span> <span class="nv">user</span> <span class="p">{</span><span class="ss">:ids</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="ss">:account</span> <span class="p">{</span><span class="ss">:username</span> <span class="s">&quot;user&quot;</span> <span class="ss">:password</span> <span class="s">&quot;pass&quot;</span><span class="p">}})</span>
</pre></div>
</div><div><p>Arrays are constructed using <a href='#arr'>arr</a>. The two examples below show equivalent arrays in javascript and clojurescript:</p></div><div><a name="js-array"></a><h4><i>e.3.4  &nbsp;-&nbsp; js array</i></h4><div class="highlight"><pre><span class="kd">var</span> <span class="nx">kids</span> <span class="o">=</span> <span class="p">[{</span><span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Sam&#39;</span> <span class="nx">age</span><span class="o">:</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Bob&#39;</span> <span class="nx">age</span><span class="o">:</span> <span class="mi">10</span><span class="p">}]</span>
</pre></div>
</div><div><a name="cljs-array---arr"></a><h4><i>e.3.5  &nbsp;-&nbsp; cljs array - arr</i></h4><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">kids</span> <span class="p">(</span><span class="nf">arr</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Sam&quot;</span> <span class="ss">:age</span> <span class="mi">3</span><span class="p">}</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Bob&quot;</span> <span class="ss">:age</span> <span class="mi">10</span><span class="p">}))</span>
</pre></div>
</div><div><a name="cljs-array---def*"></a><h4><i>e.3.6  &nbsp;-&nbsp; cljs array - def*</i></h4><div class="highlight"><pre><span class="p">(</span><span class="nf">def*</span> <span class="nv">kids</span> <span class="p">[{</span><span class="ss">:name</span> <span class="s">&quot;Sam&quot;</span> <span class="ss">:age</span> <span class="mi">3</span><span class="p">}</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Bob&quot;</span> <span class="ss">:age</span> <span class="mi">10</span><span class="p">}])</span>
</pre></div>
</div><div><a name="native-functions"></a><h3>3.2 &nbsp;&nbsp; Native Functions</h3></div><div><p><a href='#dot-defn'>def.n</a> and <a href='#dot-fn'>f.n</a> allow functions to be defined using the javascript <code>dot-notation</code> syntax. The following are examples of the square function defined in javascript and clojurescript.</p></div><div><a name="js-function"></a><h4><i>e.3.7  &nbsp;-&nbsp; js function</i></h4><div class="highlight"><pre><span class="nx">square</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">value</span> <span class="o">*</span> <span class="nx">x</span><span class="p">.</span><span class="nx">value</span><span class="p">}</span>
</pre></div>
</div><div><a name="cljs-function---defn"></a><h4><i>e.3.8  &nbsp;-&nbsp; cljs function - def.n</i></h4><div class="highlight"><pre><span class="p">(</span><span class="nf">def.n</span> <span class="nv">square</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">obj</span> <span class="ss">:value</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x.value</span> <span class="nv">x.value</span><span class="p">)))</span>
</pre></div>
</div><div><a name="cljs-function---fn"></a><h4><i>e.3.9  &nbsp;-&nbsp; cljs function - f.n</i></h4><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">square</span> 
  <span class="p">(</span><span class="nf">f.n</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
    <span class="p">(</span><span class="nf">obj</span> <span class="ss">:value</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x.value</span> <span class="nv">x.value</span><span class="p">))))</span>
</pre></div>
</div><div><p>As a comparison, here is the same function in clojurescript without the macro helpers.</p></div><div><a name="cljs-function---defn"></a><h4><i>e.3.10  &nbsp;-&nbsp; cljs function - defn</i></h4><div class="highlight"><pre><span class="p">(</span><span class="kd">defn </span><span class="nv">square</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">js-obj</span><span class="p">)</span>
        <span class="nv">v</span> <span class="p">(</span><span class="nb">aget </span><span class="nv">x</span> <span class="s">&quot;value&quot;</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">aset </span><span class="nv">o</span> <span class="s">&quot;value&quot;</span> <span class="p">(</span><span class="nb">* </span><span class="nv">v</span> <span class="nv">v</span><span class="p">))</span>
    <span class="nv">o</span><span class="p">))</span>
</pre></div>
</div><div><a name="native-protocols"></a><h3>3.3 &nbsp;&nbsp; Native Protocols</h3></div><div><p>The <a href='#purnam-native'>purnam.native</a> namespace provide for idiomatic clojure syntax to be used:</p></div><div><a name="idiomatic-clojure-protocols"></a><h4><i>e.3.11  &nbsp;-&nbsp; Idiomatic Clojure Protocols</i></h4><div class="highlight"><pre><span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:c</span> <span class="mi">3</span><span class="p">))</span> <span class="nv">=&gt;</span> <span class="mi">3</span>

<span class="p">(</span><span class="nb">get </span><span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:c</span> <span class="mi">3</span><span class="p">)</span> <span class="s">&quot;a&quot;</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="mi">1</span>

<span class="p">(</span><span class="nb">nth </span><span class="p">(</span><span class="nf">arr</span> <span class="ss">:0</span> <span class="ss">:1</span> <span class="ss">:2</span> <span class="ss">:3</span> <span class="ss">:4</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="ss">:3</span>
</pre></div>
</div><div><p>The <a href='#purnam-native-functions'>purnam.native.functions</a> namespace also provide additional manipulation functions like <a href='#js-merge'>js-merge</a>, <a href='#js-merge-nil'>js-merge-nil</a> and <a href='#js-deep-copy'>js-deep-copy</a>. More examples can be seen in the <a href='(#purnam-native-functions'>api</a>).</p></div><div><a name="dsl-for-testing"></a><h3>3.4 &nbsp;&nbsp; DSL for Testing</h3></div><div><p>Choose between two styles of sytax for testing clojurescript code - jasmine style or midje style (in the <a href='#purnam-test'>purnam.test</a> namespace). Or you can mix and match both of them together.</p></div><div><a name="testing---jasmine-style"></a><h4><i>e.3.12  &nbsp;-&nbsp; testing - jasmine style</i></h4><div class="highlight"><pre><span class="p">(</span><span class="nf">describe</span> <span class="s">&quot;Addition&quot;</span>
  <span class="p">(</span><span class="nf">it</span> <span class="s">&quot;should add things&quot;</span>
    <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">is-not</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">0</span><span class="p">)))</span>
</pre></div>
</div><div><a name="testing---midje-style"></a><h4><i>e.3.13  &nbsp;-&nbsp; testing - midje style</i></h4><div class="highlight"><pre><span class="p">(</span><span class="nf">fact</span> <span class="p">[[{</span><span class="ss">:doc</span> <span class="s">&quot;Addition should add things&quot;</span><span class="p">}]]</span>
  <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="mi">2</span>
  <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="mi">3</span>
  <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">3</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="mi">4</span>
  <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="o">#</span><span class="p">(</span><span class="nb">not= </span><span class="mi">0</span> <span class="nv">%</span><span class="p">))</span>
</pre></div>
</div><div><p>Although there are currently more features available when using the jasmine style syntax, using midje style syntax also allow compilation of your test files into beautiful documentation using <a href='https://www.github.com/zcaudate/lein-midje-doc'>midje-doc</a>. The current document has been generated in this way.</p></div><div><a name="purnam-native-functions"></a><h2><b>4 &nbsp;&nbsp; purnam.native.functions</b></h2></div><div><p>Clojure protocols for javascript native objects and arrays.</p></div><div><a name="init-native-functions"></a><h3>4.1 &nbsp;&nbsp; init</h3></div><div><p>To use this package, require <code>purnam.native.functions</code> in your namespace</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">purnam.native.functions</span> <span class="ss">:refer</span> <span class="p">[</span><span class="nv">js-lookup</span> <span class="nv">js-equals</span> <span class="nv">....</span><span class="p">]])</span>
</pre></div>
</div><div><p>Utility functions for javascript native objects and arrays.</p></div><div><a name="js-lookup"></a><h3>4.2 &nbsp;&nbsp; js-lookup</h3></div><div><p><code>js-lookup</code> is like <code>get</code> for native javascript. It works with keywords and strings</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">js-lookup</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1, b:2}&quot;</span><span class="p">)</span> <span class="s">&quot;a&quot;</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="mi">1</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">js-lookup</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1, b:2}&quot;</span><span class="p">)</span> <span class="ss">:b</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="mi">2</span>
</pre></div>
</div><div><a name="js-equals"></a><h3>4.3 &nbsp;&nbsp; js-equals</h3></div><div><p><code>js-equals</code> checks for equality on native objects. The clojurescript equality <code>=</code> does not check for equality on native objects</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1}&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1}&quot;</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="nv">false?</span>
</pre></div>
</div><div><p><code>js-equals</code> fills this gap:</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">js-equals</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1}&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1}&quot;</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="nv">true</span>
</pre></div>
</div><div><p><code>js-equals</code> will also check equality for nested native objects and arrays</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">js-equals</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:[{b: [{c: 1}]}]}&quot;</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:[{b: [{c: 1}]}]}&quot;</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="nv">true</span>
</pre></div>
</div><div><a name="js-assoc"></a><h3>4.4 &nbsp;&nbsp; js-assoc</h3></div><div><p><code>js-assoc</code> is the native mutable version of <code>assoc</code>, it works with both keyword and string keys</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">o</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1}&quot;</span><span class="p">))</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">js-assoc</span> <span class="nv">o</span> <span class="s">&quot;b&quot;</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1">;; string</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1,b:2}&quot;</span><span class="p">)</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">js-assoc</span> <span class="nv">o</span> <span class="ss">:c</span> <span class="mi">3</span> <span class="s">&quot;d&quot;</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1">;; keyword and string </span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1,b:2,c:3,d:4}&quot;</span><span class="p">)</span>
</pre></div>
</div><div><p><code>js-assoc</code> also works with native arrays and allows number keys</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">o</span> <span class="p">(</span><span class="nf">array</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">js-assoc</span> <span class="nv">o</span> <span class="s">&quot;1&quot;</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1">;; string</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">array</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">js-assoc</span> <span class="nv">o</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>     <span class="c1">;; number</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">array</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div><div><a name="js-dissoc"></a><h3>4.5 &nbsp;&nbsp; js-dissoc</h3></div><div><p><code>js-dissoc</code> is the native mutable version of <code>dissoc</code>, it works with both keyword and string keys</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">o</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1,b:2,c:3,d:4}&quot;</span><span class="p">))</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">js-dissoc</span> <span class="nv">o</span> <span class="s">&quot;a&quot;</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{d:4}&quot;</span><span class="p">)</span>
</pre></div>
</div><div><a name="js-empty"></a><h3>4.6 &nbsp;&nbsp; js-empty</h3></div><div><p><code>js-empty</code> is the native mutable version of <code>empty</code></p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">o</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1,b:2,c:3,d:4}&quot;</span><span class="p">))</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">js-empty</span> <span class="nv">o</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js-obj</span><span class="p">)</span>
</pre></div>
</div><div><a name="js-merge"></a><h3>4.7 &nbsp;&nbsp; js-merge</h3></div><div><p><code>js-merge</code> is the native mutable version of <code>merge</code>. It will only mutate the first object argument.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">o1</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1}&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">o2</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{b:2}&quot;</span><span class="p">))</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">js-merge</span> <span class="nv">o1</span> <span class="nv">o2</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1,b:2}&quot;</span><span class="p">)</span>
</pre></div>
</div><div><p>If the keys are the same, it will overwrite</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">o3</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{b:3}&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">js-merge</span> <span class="nv">o1</span> <span class="nv">o3</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1,b:3}&quot;</span><span class="p">)</span>
</pre></div>
</div><div><a name="js-merge-nil"></a><h3>4.8 &nbsp;&nbsp; js-merge-nil</h3></div><div><p><code>js-merge-nil</code> is like <code>js-merge</code> but it will only merge the keys that are not defined</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">o1</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1}&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">o2</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:2,b:2}&quot;</span><span class="p">))</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">js-merge-nil</span> <span class="nv">o1</span> <span class="nv">o2</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1,b:2}&quot;</span><span class="p">)</span>
</pre></div>
</div><div><a name="js-copy"></a><h3>4.9 &nbsp;&nbsp; js-copy</h3></div><div><p><code>js-copy</code> creates another object with the same key/values</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">o1</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1,b:2}&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">o2</span> <span class="p">(</span><span class="nf">js-copy</span> <span class="nv">o1</span><span class="p">))</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">js-equals</span> <span class="nv">o1</span> <span class="nv">o2</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="nv">true</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nb">= </span><span class="nv">o1</span> <span class="nv">o2</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="nv">false</span>
</pre></div>
</div><div><a name="js-deep-copy"></a><h3>4.10 &nbsp;&nbsp; js-deep-copy</h3></div><div><p><code>js-deep-copy</code> copys everything about an object, including circular references</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">o1</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;function(){var a = {val:1}; a.ref = a; return a;}()&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">o2</span> <span class="p">(</span><span class="nf">js-deep-copy</span> <span class="nv">o1</span><span class="p">))</span>
</pre></div>
</div><div><p>Notice that we can walk o2.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nb">aget </span><span class="nv">o2</span> <span class="s">&quot;ref&quot;</span> <span class="s">&quot;ref&quot;</span> <span class="s">&quot;val&quot;</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="mi">1</span>
</pre></div>
</div><div><p>But o1 and o2 are not equal</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nb">= </span><span class="nv">o1</span> <span class="nv">o2</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="nv">false?</span>
</pre></div>
</div><div><p>And neither are the references</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">aget </span><span class="nv">o1</span> <span class="s">&quot;ref&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nb">aget </span><span class="nv">o2</span> <span class="s">&quot;ref&quot;</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="nv">false?</span>
</pre></div>
</div><div><a name="js-replace"></a><h3>4.11 &nbsp;&nbsp; js-replace</h3></div><div><p><code>js-replace</code> is like <code>js-copy</code>, but it uses keeps the pointer to the first object argument</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">o1</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1}&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">js-replace</span> <span class="nv">o1</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{b:2}&quot;</span><span class="p">))</span>

<span class="nv">o1</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{b:2}&quot;</span><span class="p">)</span>
</pre></div>
</div><div><a name="js-map"></a><h3>4.12 &nbsp;&nbsp; js-map</h3></div><div><p>A multi argument version of map, like clojure's map but returns a native arrays</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">js-map</span> <span class="nb">+ </span><span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[1,2,3,4]&quot;</span><span class="p">)</span> 
          <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[5,6,7,8]&quot;</span><span class="p">)</span> 
          <span class="p">[</span><span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span><span class="p">])</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[15,18,21,24]&quot;</span><span class="p">)</span>
</pre></div>
</div><div><a name="js-concat"></a><h3>4.13 &nbsp;&nbsp; js-concat</h3></div><div><p>Concats multiple arrays into a single native arrays</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">js-concat</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[1,2,3,4]&quot;</span><span class="p">)</span> 
         <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[5,6,7,8]&quot;</span><span class="p">)</span> 
         <span class="p">[</span><span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span><span class="p">])</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[1,2,3,4,5,6,7,8,9,10,11,12]&quot;</span><span class="p">)</span>
</pre></div>
</div><div><a name="js-mapcat"></a><h3>4.14 &nbsp;&nbsp; js-mapcat</h3></div><div><p>Like clojure's mapcat but returns a native arrays</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">js-mapcat</span> <span class="nb">list </span><span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[1,2,3,4]&quot;</span><span class="p">)</span> 
                <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[5,6,7,8]&quot;</span><span class="p">)</span> 
                <span class="p">[</span><span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span><span class="p">])</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[1,5,9,2,6,10,3,7,11,4,8,12]&quot;</span><span class="p">)</span>
</pre></div>
</div><div><a name="js-arities"></a><h3>4.15 &nbsp;&nbsp; js-arities</h3></div><div><p>Returns all arities of a function. Works with f.n and def.n</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">js-arities</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="nv">x</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div><div><a name="purnam-native"></a><h2><b>5 &nbsp;&nbsp; purnam.native</b></h2></div><div><p>Clojure protocols for javascript native objects and arrays.</p></div><div><a name="init-native"></a><h3>5.1 &nbsp;&nbsp; init</h3></div><div><p>To use this package, require <code>purnam.native</code> in your namespace</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">purnam.native</span><span class="p">])</span>
</pre></div>
</div><div><a name="seq-protocol"></a><h3>5.2 &nbsp;&nbsp; seq protocol</h3></div><div><p>The <code>seq</code> can now be used on native js arrays and objects.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nb">seq </span><span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[1, 2, 3, 4]&quot;</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nb">seq </span><span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1, b:2}&quot;</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="o">&#39;</span><span class="p">([</span><span class="s">&quot;a&quot;</span> <span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="s">&quot;b&quot;</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div><div><p>As well as all the built-in functionality that come with it. Although the datastructure then becomes a clojurescript lazyseq.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">%</span><span class="p">)</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[1, 2, 3, 4]&quot;</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">8</span><span class="p">)</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nb">take </span><span class="mi">2</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[1, 2, 3, 4]&quot;</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[1, 2, 3, 4]&quot;</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="mi">4</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nb">get </span><span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[1, 2, 3, 4]&quot;</span><span class="p">)</span> <span class="s">&quot;1&quot;</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="mi">2</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">get-in</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:{b:{c:1}}}&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&quot;</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="mi">1</span>
</pre></div>
</div><div><a name="transient-protocol"></a><h3>5.3 &nbsp;&nbsp; transient protocol</h3></div><div><p>Transient protocol allow native js objects arrays to be manipulated using assoc!, dissoc! and persistent!</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">js-obj</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">assoc!</span> <span class="nv">o</span> <span class="ss">:a</span> <span class="mi">1</span><span class="p">)</span>
  <span class="nv">o</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1}&quot;</span><span class="p">)</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1}&quot;</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">dissoc!</span> <span class="nv">o</span> <span class="ss">:a</span><span class="p">)</span>
  <span class="nv">o</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js-obj</span><span class="p">)</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">persistent!</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1}&quot;</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span><span class="p">}</span>
</pre></div>
</div><div><a name="collection-protocol"></a><h3>5.4 &nbsp;&nbsp; collection protocol</h3></div><div><p>Extension of clojure collection protocols allow native js objects arrays to use <code>conj</code>, <code>assoc</code> and <code>dissoc</code> methods.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">o</span> <span class="p">(</span><span class="nf">js-obj</span><span class="p">))</span>
  <span class="p">(</span><span class="k">def </span><span class="nv">o1</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">o</span> <span class="p">[</span><span class="ss">:a</span> <span class="mi">1</span><span class="p">]))</span>
  <span class="nv">o</span> <span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js-obj</span><span class="p">)</span>
  <span class="nv">o1</span> <span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1}&quot;</span><span class="p">)</span>
  
</pre></div>
</div><div><p>It works with both arrays and objects</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[1]&quot;</span><span class="p">)</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[1,2,3]&quot;</span><span class="p">)</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1}&quot;</span><span class="p">)</span> <span class="p">[</span><span class="ss">:b</span> <span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="ss">:c</span> <span class="mi">3</span><span class="p">])</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1,b:2,c:3}&quot;</span><span class="p">)</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nb">assoc </span><span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1}&quot;</span><span class="p">)</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:c</span> <span class="mi">3</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1,b:2,c:3}&quot;</span><span class="p">)</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nb">dissoc </span><span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1}&quot;</span><span class="p">)</span> <span class="ss">:a</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js-obj</span><span class="p">)</span>
</pre></div>
</div><div><a name="purnam-core"></a><h2><b>6 &nbsp;&nbsp; purnam.core</b></h2></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">set-safe-aget</span> <span class="nv">true</span><span class="p">)</span>
</pre></div>
</div><div><a name="init-core"></a><h3>6.1 &nbsp;&nbsp; init</h3></div><div><p><code>purnam.core</code> extensions are packaged as macros. They are accessible via <code>:use-macro</code> declaration.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="ss">:use-macros</span> <span class="p">[</span><span class="nv">purnam.core</span> <span class="ss">:only</span> <span class="p">[</span><span class="nv">?</span> <span class="nv">?&gt;</span> <span class="nv">!</span> <span class="nv">!&gt;</span> <span class="nv">f.n</span> <span class="nv">def.n</span> <span class="nv">do.n</span>
                                <span class="nv">obj</span> <span class="nv">arr</span> <span class="nv">def*</span> <span class="nv">do*n</span> <span class="nv">def*n</span> <span class="nv">f*n</span><span class="p">]])</span>
</pre></div>
</div><div><a name="obj"></a><h3>6.2 &nbsp;&nbsp; obj</h3></div><div><p>Raw js objects are constructed in clojurescript with <code>obj</code>:</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">obj</span> <span class="s">&quot;key1&quot;</span> <span class="s">&quot;val1&quot;</span> <span class="s">&quot;key2&quot;</span> <span class="s">&quot;val2&quot;</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{key1: &#39;val1&#39;, key2: &#39;val2&#39;}&quot;</span><span class="p">)</span>
</pre></div>
</div><div><p>Keywords can be used instead of strings for improved legibility. The previous example can also be written as:</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">obj</span> <span class="ss">:key1</span> <span class="s">&quot;val1&quot;</span> <span class="ss">:key2</span> <span class="s">&quot;val2&quot;</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{key1: &#39;val1&#39;, key2: &#39;val2&#39;}&quot;</span><span class="p">)</span>
</pre></div>
</div><div><p>Symbol are evalutated. This will produce an equivalent object to the previous examples:</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">s1</span> <span class="s">&quot;key1&quot;</span>
      <span class="nv">s2</span> <span class="s">&quot;key2&quot;</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">obj</span> <span class="nv">s1</span> <span class="s">&quot;val1&quot;</span> <span class="nv">s2</span> <span class="s">&quot;val2&quot;</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{key1: &#39;val1&#39;, key2: &#39;val2&#39;}&quot;</span><span class="p">)</span>
</pre></div>
</div><div><p>Note that the symbols have to represent strings to get the same output as previous. The following WILL NOT construct the equivalent object as before:</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">s1</span> <span class="ss">:key1</span>
      <span class="nv">s2</span> <span class="ss">:key2</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">obj</span> <span class="nv">s1</span> <span class="s">&quot;val1&quot;</span> <span class="nv">s2</span> <span class="s">&quot;val2&quot;</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="o">#</span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">= </span><span class="nv">%</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{key1: &#39;val1&#39;, key2: &#39;val2&#39;}&quot;</span><span class="p">)))</span>
</pre></div>
</div><div><p>The <code>obj</code> form can be used to set up nested js objects and arrays primitives. Using <code>&#91;&#93;</code> with the form will create a new js array, <code>{}</code> will create a new js object.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">obj</span> <span class="ss">:data</span> <span class="p">[{</span><span class="ss">:id</span> <span class="mi">1</span> <span class="ss">:name</span> <span class="s">&quot;one&quot;</span><span class="p">}</span>
            <span class="p">{</span><span class="ss">:id</span> <span class="mi">2</span> <span class="ss">:name</span> <span class="s">&quot;two&quot;</span><span class="p">}])</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{data: [{id:1,name:&#39;one&#39;},</span>
<span class="s">                 {id:2,name:&#39;two&#39;}]}&quot;</span><span class="p">)</span>
</pre></div>
</div><div><p>The nesting notation alleviates the use of the clj-&gt;js transform for constructing large javascipt variables. In this way, deeply nested javascript object structures can be created in clojurescript in the same way clojure maps and arrays are created.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">obj</span> <span class="ss">:name</span> <span class="s">&quot;l1&quot;</span> <span class="ss">:data</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
     <span class="ss">:next</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;l2&quot;</span> <span class="ss">:data</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]</span>
            <span class="ss">:next</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;l3&quot;</span> <span class="ss">:data</span> <span class="p">[</span><span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">]}})</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{name: &#39;l1&#39;,</span>
<span class="s">          data: [1,2,3],</span>
<span class="s">          next: {name: &#39;l2&#39;,</span>
<span class="s">                 data: [4,5,6],</span>
<span class="s">                 next: {name: &#39;l3&#39;,</span>
<span class="s">                        data: [7,8,9]}}}&quot;</span><span class="p">)</span>
</pre></div>
</div><div><a name="arr"></a><h3>6.3 &nbsp;&nbsp; arr</h3></div><div><p><code>arr</code> constructs a javascript array primitive, the same way as <code>array</code></p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">arr</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[1,2,3,4,5]&quot;</span><span class="p">)</span>
</pre></div>
</div><div><p><code>arr</code> supports nesting of native objects and arrays much like <code>obj</code></p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">arr</span> <span class="p">{</span><span class="ss">:data</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]}</span>
     <span class="p">{</span><span class="ss">:data</span> <span class="p">[</span><span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span><span class="p">]})</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[{data: [1,2,3,4,5]},</span>
<span class="s">            {data: [6,7,8,9,10]}]&quot;</span><span class="p">)</span>
</pre></div>
</div><div><a name="getter"></a><h3>6.4 &nbsp;&nbsp; getter - ?</h3></div><div><p><code>?</code> provides javascript-like dot notation access for objects</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:c</span> <span class="mi">3</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">?</span> <span class="nv">o.a</span><span class="p">)</span> <span class="p">(</span><span class="nf">?</span> <span class="nv">o.b</span><span class="p">)</span> <span class="p">(</span><span class="nf">?</span> <span class="nv">o.c</span><span class="p">)))</span>

<span class="nv">=&gt;</span> <span class="mi">6</span>
</pre></div>
</div><div><p>Pipe notation <code>object.|key|</code> provides symbol lookup</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:c</span> <span class="mi">3</span><span class="p">)</span>
      <span class="nv">k</span> <span class="s">&quot;a&quot;</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">?</span> <span class="nv">o.b</span><span class="p">)</span> <span class="p">(</span><span class="nf">?</span> <span class="nv">o.</span><span class="err">|</span><span class="nv">k</span><span class="err">|</span><span class="p">)))</span>

<span class="nv">=&gt;</span> <span class="mi">1</span>
</pre></div>
</div><div><p><code>?</code> also works on javascript arrays</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">arr</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]</span> <span class="p">[</span><span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">])]</span>
   <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">?</span> <span class="nv">o.2.2</span><span class="p">)</span> <span class="p">(</span><span class="nf">?</span> <span class="nv">o.0.0</span><span class="p">)))</span>

<span class="nv">=&gt;</span> <span class="mi">8</span>
</pre></div>
</div><div><p>If any of the keys are missing, <code>?</code> will not throw an object <code>undefined</code> exception but will return <code>nil</code>.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">obj</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">?</span> <span class="nv">o.any.nested.syntax</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="nv">nil?</span>
</pre></div>
</div><div><a name="setter"></a><h3>6.5 &nbsp;&nbsp; setter - !</h3></div><div><p>The <code>!</code> form provides setting using dot notation:</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">obj</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">!</span> <span class="nv">o.a</span> <span class="mi">6</span><span class="p">)</span>  
  <span class="p">(</span><span class="nf">?</span> <span class="nv">o.a</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="mi">6</span>
</pre></div>
</div><div><p>Pipe notation <code>object.|key|</code> also works</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">obj</span><span class="p">)</span>
      <span class="nv">k</span> <span class="s">&quot;a&quot;</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">!</span> <span class="nv">o.</span><span class="err">|</span><span class="nv">k</span><span class="err">|</span> <span class="mi">6</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">?</span> <span class="nv">o.a</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="mi">6</span>
</pre></div>
</div><div><p>If there is no value or the value is <code>nil</code>, <code>!</code> will delete the key from the object:</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">1</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">!</span> <span class="nv">o.a</span><span class="p">)</span>
  <span class="nv">o</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">obj</span><span class="p">)</span>
</pre></div>
</div><div><p>If the hierachy of nested objects does not exist, <code>!</code> will create it</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">obj</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">!</span> <span class="nv">o.a.b.c</span> <span class="mi">10</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">?</span> <span class="nv">o.a.b.c</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="mi">10</span>
</pre></div>
</div><div><p>If one of the keys in the object accessor is not an object, <code>!</code> WILL NOT create nested structures</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">1</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">!</span> <span class="nv">o.a.b.c</span> <span class="mi">10</span><span class="p">)</span>
  <span class="p">[(</span><span class="nf">?</span> <span class="nv">o.a.b.c</span><span class="p">)</span> <span class="p">(</span><span class="nf">?</span> <span class="nv">o.a</span><span class="p">)])</span>

<span class="nv">=&gt;</span> <span class="p">[</span><span class="nv">nil</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div><div><a name="call"></a><h3>6.6 &nbsp;&nbsp; call - ?></h3></div><div><p>?&gt; allows function calls with dot-notation syntax.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o1</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">1</span><span class="p">)</span>
      <span class="nv">o2</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">3</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">?&gt;</span> <span class="nb">+ </span><span class="nv">o1.a</span> <span class="nv">o2.a</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="mi">4</span>
</pre></div>
</div><div><p>Inner forms within ?&gt; are automatically interpreted using dot-notation. There is no need to write <code>?</code>.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">?&gt;</span> <span class="nv">.map</span> <span class="p">(</span><span class="nf">arr</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span><span class="p">}</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">2</span><span class="p">}</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">3</span><span class="p">})</span>
         <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">x.a</span><span class="p">)))</span> <span class="c1">;; no need to write (inc (? x.a))</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">arr</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div><div><a name="call-on"></a><h3>6.7 &nbsp;&nbsp; call on - !></h3></div><div><p>The !&gt; form allows for writing dot-notation function calls.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nf">arr</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">!&gt;</span> <span class="nv">a.push</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">!&gt;</span> <span class="nv">a.push</span> <span class="mi">2</span><span class="p">)</span>
  <span class="nv">a</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">arr</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div><div><p>We can also use pipe notation to dynamically invoke our function.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nf">arr</span><span class="p">)</span>
      <span class="nv">k</span> <span class="s">&quot;push&quot;</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">!&gt;</span> <span class="nv">a.</span><span class="err">|</span><span class="nv">k</span><span class="err">|</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">!&gt;</span> <span class="nv">a.</span><span class="err">|</span><span class="nv">k</span><span class="err">|</span> <span class="mi">2</span><span class="p">)</span>
  <span class="nv">a</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">arr</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div><div><a name="this"></a><h3>6.8 &nbsp;&nbsp; this</h3></div><div><p>The rational for adding <code>this</code> back into our language is that when a piece of a program really needs to work with existing javascript libraries (and it usually does), then clojurescript should give allow the flexibility to do that without adding additional noise to the code. Use with care!</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o1</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">10</span> 
              <span class="ss">:func</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="nv">this.a</span><span class="p">))</span>
      <span class="nv">o2</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">20</span>
              <span class="ss">:func</span> <span class="nv">o1.func</span><span class="p">)]</span>
  <span class="p">[(</span><span class="nf">!&gt;</span> <span class="nv">o1.func</span><span class="p">)</span> <span class="p">(</span><span class="nf">!&gt;</span> <span class="nv">o2.func</span><span class="p">)])</span>

<span class="nv">=&gt;</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">20</span><span class="p">]</span>
</pre></div>
</div><div><p>When <code>this</code> is nested, it works within the scope of the nested object</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">10</span>
             <span class="ss">:func</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="nv">this.a</span><span class="p">)</span>
             <span class="ss">:b</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">20</span>
                 <span class="ss">:func</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="nv">this.a</span><span class="p">)})]</span>
  <span class="p">[(</span><span class="nf">!&gt;</span> <span class="nv">o.func</span><span class="p">)</span> <span class="p">(</span><span class="nf">!&gt;</span> <span class="nv">o.b.func</span><span class="p">)])</span>

<span class="nv">=&gt;</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">20</span><span class="p">]</span>
</pre></div>
</div><div><a name="self"></a><h3>6.9 &nbsp;&nbsp; self</h3></div><div><p>A new existential construct has been added, it be use <strong>only</strong> within the <code>obj</code> form. It is used to refer to the object itself and does not change contexts the way <code>this</code> does. It provides a somewhat safer self reference which does not change when the context is changed.</p></div><div><p><code>self</code> is similar to <code>this</code>. Note that the two keywords both refer to the object itself.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">1</span>
             <span class="ss">:thisfn</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="nv">this.a</span><span class="p">)</span>
             <span class="ss">:selffn</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="nv">self.a</span><span class="p">))]</span>
    <span class="p">[(</span><span class="nf">!&gt;</span> <span class="nv">o.thisfn</span><span class="p">)</span> <span class="p">(</span><span class="nf">!&gt;</span> <span class="nv">o.selffn</span><span class="p">)])</span>

<span class="nv">=&gt;</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div><div><p>We can quickly see the difference by creating another object. <code>o1</code> has been initiated with functions defined <code>o</code>. If we invoke the <code>o1</code> functions, it can be seen that the context for <code>o.thisfn</code> has changed and so it returns <code>o1.a</code> (2). While <code>o1.selffn</code> returns the value <code>o.a</code> (1)</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">1</span>
             <span class="ss">:thisfn</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="nv">this.a</span><span class="p">)</span>
             <span class="ss">:selffn</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="nv">self.a</span><span class="p">))</span>
      <span class="nv">o1</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">2</span>
             <span class="ss">:thisfn</span> <span class="nv">o.thisfn</span>
             <span class="ss">:selffn</span> <span class="nv">o.selffn</span><span class="p">)]</span>
  <span class="p">[(</span><span class="nf">!&gt;</span> <span class="nv">o1.thisfn</span><span class="p">)</span> <span class="p">(</span><span class="nf">!&gt;</span> <span class="nv">o1.selffn</span><span class="p">)])</span>

<span class="nv">=&gt;</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div><div><p>A useful property of <code>obj</code> and <code>self</code> can be seen in the next example. Even though both have the same structure, <code>self</code> in <code>a1</code> refers to a1 whereas <code>self</code> in a2 refers to a2.b. This was due to the fact that in <code>a1</code>, a hashmap was used to construct :b as opposed to the <code>obj</code> form in <code>a2</code>.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a1</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">1</span>
              <span class="ss">:b</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">2</span>         <span class="c1">;; Note {} is used</span>
                  <span class="ss">:func</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="nv">self.a</span><span class="p">)})</span>
      <span class="nv">a2</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">1</span>
              <span class="ss">:b</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">2</span>   <span class="c1">;; Note obj is used</span>
                      <span class="ss">:func</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="nv">self.a</span><span class="p">)))]</span>
    <span class="p">[(</span><span class="nf">!&gt;</span> <span class="nv">a1.b.func</span><span class="p">)</span> <span class="p">(</span><span class="nf">!&gt;</span> <span class="nv">a2.b.func</span><span class="p">)])</span>

<span class="nv">=&gt;</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div><div><a name="dot-defn"></a><h3>6.10 &nbsp;&nbsp; def.n</h3></div><div><p><code>def.n</code> allow construction of functions with the javascript dot-notation. Within the forms, there is no need to add <a href='#getter'>?</a>, <a href='#call'>?&gt;</a> and <a href='#call-on'>!&gt;</a> forms:</p></div><div><p>? getters are automatic</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">?</span> <span class="nv">a.b</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="nv">a.b</span>
</pre></div>
</div><div><p>?&gt; call syntax is automatically applied</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">?&gt;</span> <span class="nb">+ </span><span class="nv">a.b</span> <span class="nv">c.d</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a.b</span> <span class="nv">c.d</span><span class="p">)</span>
</pre></div>
</div><div><p>!&gt; syntax is also automatically applied:</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">!&gt;</span> <span class="nv">a.b</span> <span class="nv">c.d</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">a.b</span> <span class="nv">c.d</span><span class="p">)</span>
</pre></div>
</div><div><p>The <code>defn</code> function:</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="kd">defn </span><span class="nv">dostuff0</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">!&gt;</span> <span class="nv">b.func</span> <span class="mi">10</span> <span class="mi">10</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">?&gt;</span> <span class="nb">+ </span><span class="nv">a.val</span> <span class="nv">b.val</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">?</span> <span class="nv">c.val</span><span class="p">)))</span>
</pre></div>
</div><div><p>Can be written more succinctly using <code>def.n</code>:</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">def.n</span> <span class="nv">dostuff1</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">b.func</span> <span class="mi">10</span> <span class="mi">10</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+ </span><span class="nv">a.val</span> <span class="nv">b.val</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">inc </span><span class="nv">c.val</span><span class="p">))</span>
</pre></div>
</div><div><a name="dot-fn"></a><h3>6.11 &nbsp;&nbsp; f.n</h3></div><div><p><code>f.n</code> is the equivalent dot-notation counterpart for <code>fn</code></p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">dostuff2</span> 
  <span class="p">(</span><span class="nf">f.n</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">]</span>
    <span class="p">(</span><span class="nf">b.func</span> <span class="mi">10</span> <span class="mi">10</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+ </span><span class="nv">a.val</span> <span class="nv">b.val</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">inc </span><span class="nv">c.val</span><span class="p">)))</span>
</pre></div>
</div><div><a name="dot-do"></a><h3>6.12 &nbsp;&nbsp; do.n</h3></div><div><p>The <code>do.n</code> block is like <code>do</code> but allows dot-notation syntax:</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">do.n</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">obj</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">!</span> <span class="nv">o.val.a</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">!</span> <span class="nv">o.val.b</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+ </span><span class="nv">o.val.a</span> <span class="nv">o.val.b</span><span class="p">)))</span>

<span class="nv">=&gt;</span> <span class="mi">3</span>
</pre></div>
</div><div><a name="raw"></a><h3>6.13 &nbsp;&nbsp; raw forms</h3></div><div><p>For those that want to write clojurescript with <code>{}</code> interpreted as js objects and <code>&#91;&#93;</code> interpreted as arrays, then the raw js forms are very handy. <code>def&#42;</code>, <code>def&#42;n</code>, <code>f&#42;n</code> and <code>do&#42;n</code> allow this. The same function <code>raw-fn</code> can be defined the following four ways:</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">raw-fn</span> <span class="p">(</span><span class="nf">f*n</span> <span class="p">[</span><span class="nv">o</span><span class="p">]</span> <span class="p">(</span><span class="nf">!</span> <span class="nv">o.val</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">])))</span>

<span class="p">(</span><span class="nf">def*</span> <span class="nv">raw-fn</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">o</span><span class="p">]</span> <span class="p">(</span><span class="nf">!</span> <span class="nv">o.val</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">])))</span>

<span class="p">(</span><span class="nf">def*n</span> <span class="nv">raw-fn</span> <span class="p">[</span><span class="nv">o</span><span class="p">]</span> <span class="p">(</span><span class="nf">!</span> <span class="nv">o.val</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]))</span>

<span class="p">(</span><span class="nf">do*n</span> <span class="p">(</span><span class="k">def </span><span class="nv">raw-fn</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">o</span><span class="p">]</span> <span class="p">(</span><span class="nf">!</span> <span class="nv">o.val</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">])</span> <span class="nv">o</span><span class="p">)))</span>
</pre></div>
</div><div><p>where</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">raw-fn</span> <span class="p">(</span><span class="nf">obj</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:val</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">])</span>
</pre></div>
</div><div><p>Within the raw js form, <code>self</code> refers to the top level object.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">def*</span> <span class="nv">o</span> <span class="p">(</span><span class="nf">obj</span> <span class="ss">:a</span> <span class="mi">10</span>
             <span class="ss">:b</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">20</span>
                 <span class="ss">:func</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="nv">self.a</span><span class="p">)}))</span>

<span class="p">(</span><span class="nf">!&gt;</span> <span class="nv">o.b.func</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="mi">10</span>
</pre></div>
</div><div><p>The raw js forms will only recognise the <code>cljs.core</code> vector binding constructs: <code>let</code>, <code>loop</code>, <code>for</code>, <code>doseq</code>, <code>if-let</code> and <code>when-let</code>. Any custom macros within a raw form will run into problems.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">set-safe-aget</span> <span class="nv">false</span><span class="p">)</span>
</pre></div>
</div><div><a name="purnam-test"></a><h2><b>7 &nbsp;&nbsp; purnam.test</b></h2></div><div><a name="init"></a><h3>7.1 &nbsp;&nbsp; init</h3></div><div><p>All tests require the following within the namespace declaration.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">purnam.test</span><span class="p">])</span>
<span class="p">(</span><span class="ss">:use-macros</span> <span class="p">[</span><span class="nv">purnam.test</span> <span class="ss">:only</span> <span class="p">[</span><span class="nv">describe</span> <span class="nv">it</span> <span class="nv">is</span> <span class="nv">is-not</span><span class="p">]])</span>
</pre></div>
</div><div><p><strong>PLEASE NOTE</strong>: <code>&#40;:require &#91;purnam.test&#93;&#41;</code> must be placed inside your namespace. This configures jasmine with the correct checker so that tests can be run. There will be random errors outputted without it when karma is run.</p></div><div><a name="describe"></a><h3>7.2 &nbsp;&nbsp; describe</h3></div><div><p><code>describe</code> is the top-level form for testing. Its usage is in combination with the setup clause <code>it</code> and the checkers <code>is</code> and <code>is-not</code>. <code>:globals</code> sets up bindings for variables that can be manipulated but cannot be rebounded. <code>:vars</code> are allowed to be rebounded.</p></div><div><a name="describe-purnam-example"></a><h4><i>e.7.1  &nbsp;-&nbsp; describe purnam example</i></h4><div class="highlight"><pre><span class="p">(</span><span class="nf">describe</span>
   <span class="p">{</span><span class="ss">:doc</span> <span class="s">&quot;an example test description&quot;</span>
    <span class="ss">:globals</span> <span class="p">[</span><span class="nv">ka</span> <span class="s">&quot;a&quot;</span>
              <span class="nv">kb</span> <span class="s">&quot;b&quot;</span><span class="p">]</span>
    <span class="ss">:vars</span> <span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1,b:2,c:3}&quot;</span><span class="p">)</span>
           <span class="nv">y</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[[1, 2, 3],</span>
<span class="s">                    [4, 5, 6],</span>
<span class="s">                    [7, 8, 9]]&quot;</span><span class="p">)]}</span>

   <span class="p">(</span><span class="nf">it</span> <span class="s">&quot;dot notation for native objects&quot;</span>
       <span class="p">(</span><span class="nf">is</span> <span class="mi">1</span> <span class="nv">o.a</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">is</span> <span class="mi">6</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">o.a</span> <span class="nv">o.b</span> <span class="nv">o.c</span><span class="p">)))</span>

   <span class="p">(</span><span class="nf">it</span> <span class="s">&quot;support for both native and cljs comparisons&quot;</span>
       <span class="p">(</span><span class="nf">is</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]))</span>

   <span class="p">(</span><span class="nf">it</span> <span class="s">&quot;support for function comparison&quot;</span>
       <span class="p">(</span><span class="nf">is</span> <span class="mi">2</span> <span class="nv">even?</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">is-not</span> <span class="mi">2</span> <span class="nv">odd?</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">is</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">comp not </span><span class="nv">even?</span><span class="p">)))</span>

   <span class="p">(</span><span class="nf">it</span> <span class="s">&quot;globals&quot;</span>
       <span class="p">(</span><span class="nf">is</span> <span class="nv">o.</span><span class="err">|</span><span class="nv">ka</span><span class="err">|</span> <span class="mi">1</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">is</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">o.</span><span class="err">|</span><span class="nv">ka</span><span class="err">|</span> <span class="nv">o.</span><span class="err">|</span><span class="nv">kb</span><span class="err">|</span><span class="p">))))</span>
</pre></div>
</div><div><a name="async"></a><h3>7.3 &nbsp;&nbsp; async</h3></div><div><p>An example of testing async functionality can be seen</p></div><div><a name="async-macros"></a><h4><i>e.7.2  &nbsp;-&nbsp; async macros</i></h4><div class="highlight"><pre><span class="p">(</span><span class="nf">describe</span> <span class="p">{</span><span class="ss">:doc</span>  <span class="s">&quot;Testing Async macros&quot;</span>
           <span class="ss">:vars</span> <span class="p">[</span><span class="nv">flag</span> <span class="p">(</span><span class="nf">atom</span> <span class="nv">false</span><span class="p">)</span> 
                  <span class="nv">value</span> <span class="p">(</span><span class="nf">atom</span> <span class="mi">0</span><span class="p">)]}</span>
  <span class="p">(</span><span class="nf">it</span> <span class="s">&quot;Should support async execution of test preparation and exepectations&quot;</span>
    <span class="p">(</span><span class="nf">runs</span> <span class="p">(</span><span class="nf">js/setTimeout</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="p">(</span><span class="nf">reset!</span> <span class="nv">flag</span> <span class="nv">true</span><span class="p">))</span> <span class="mi">500</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">waits-for</span> <span class="s">&quot;Flag should be true&quot;</span> <span class="mi">750</span> <span class="p">(</span><span class="nf">swap!</span> <span class="nv">value</span> <span class="nv">inc</span><span class="p">)</span> <span class="o">@</span><span class="nv">flag</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">runs</span> <span class="p">(</span><span class="nf">is</span> <span class="o">@</span><span class="nv">flag</span> <span class="nv">true</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">&gt; </span><span class="o">@</span><span class="nv">value</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">true</span><span class="p">))))</span>
</pre></div>
</div><div><a name="fact"></a><h3>7.4 &nbsp;&nbsp; fact</h3></div><div><p><code>fact</code> is the default form for testing. It can currently only use the =&gt; checker and is a much lighter version of <a href='https://www.github.com/Marick/midje'>midje</a>. However, it is enough for all but the most common cases. The <a href='#describe'>describe</a> example is rewritten below:</p></div><div><a name="fact-form-example"></a><h4><i>e.7.3  &nbsp;-&nbsp; fact form example</i></h4><div class="highlight"><pre><span class="p">(</span><span class="nf">fact</span> <span class="p">[[{</span><span class="ss">:doc</span> <span class="s">&quot;an example test description&quot;</span>
         <span class="ss">:globals</span> <span class="p">[</span><span class="nv">ka</span> <span class="s">&quot;a&quot;</span>
                   <span class="nv">kb</span> <span class="s">&quot;b&quot;</span><span class="p">]</span>
         <span class="ss">:vars</span> <span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1,b:2,c:3}&quot;</span><span class="p">)</span>
                <span class="nv">y</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;[[1, 2, 3],</span>
<span class="s">                         [4, 5, 6],</span>
<span class="s">                         [7, 8, 9]]&quot;</span><span class="p">)]}]]</span>

 <span class="s">&quot;dot notation for native objects&quot;</span>
 <span class="nv">o.a</span> <span class="nv">=&gt;</span> <span class="mi">1</span>
 <span class="p">(</span><span class="nb">+ </span><span class="nv">o.a</span> <span class="nv">o.b</span> <span class="nv">o.c</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="mi">6</span>

 <span class="s">&quot;support for both native and cljs comparisons&quot;</span>
 <span class="nv">o</span> <span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">js*</span> <span class="s">&quot;{a:1,b:2,c:3}&quot;</span><span class="p">)</span>
 <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span> <span class="nv">=&gt;</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
 
 <span class="s">&quot;support for function comparison&quot;</span>
  <span class="mi">2</span> <span class="nv">=&gt;</span> <span class="nv">even?</span>
  <span class="mi">3</span> <span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">comp not </span><span class="nv">even?</span><span class="p">)</span>
  
 <span class="s">&quot;globals&quot;</span>
  <span class="nv">o.</span><span class="err">|</span><span class="nv">ka</span><span class="err">|</span> <span class="nv">=&gt;</span> <span class="mi">1</span>
  <span class="p">(</span><span class="nb">+ </span><span class="nv">o.</span><span class="err">|</span><span class="nv">ka</span><span class="err">|</span> <span class="nv">o.</span><span class="err">|</span><span class="nv">kb</span><span class="err">|</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="mi">3</span>
  
  <span class="s">&quot;vars are allowed to be rebound&quot;</span>              
  <span class="p">(</span><span class="nb">- </span><span class="nv">y.2.2</span> <span class="nv">y.0.0</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="mi">8</span>
  <span class="p">)</span>
</pre></div>
</div><div><a name="facts"></a><h3>7.5 &nbsp;&nbsp; facts</h3></div><div><p><code>facts</code> and <code>fact</code> are interchangeable. The difference is how they are rendered in a document. See <a href='http://docs.caudate.me/lein-midje-doc#facts'>lein-midje-doc</a> for more details.</p></div><div><a name="facts-form-example"></a><h4><i>e.7.4  &nbsp;-&nbsp; facts form example</i></h4><div class="highlight"><pre><span class="p">(</span><span class="nf">facts</span> <span class="p">[[{</span><span class="ss">:doc</span> <span class="s">&quot;Basic Hashmaps&quot;</span>
          <span class="ss">:globals</span> <span class="p">[</span><span class="nv">o</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:c</span> <span class="mi">3</span><span class="p">}]}]]</span>
  <span class="p">(</span><span class="nf">o</span> <span class="ss">:a</span><span class="p">)</span>       <span class="nv">=&gt;</span> <span class="mi">1</span> 
  <span class="p">(</span><span class="nf">o</span> <span class="ss">:a</span><span class="p">)</span>       <span class="nv">=&gt;</span> <span class="o">#</span><span class="p">(</span><span class="nb">not= </span><span class="mi">0</span> <span class="nv">%</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">get </span><span class="nv">o</span> <span class="ss">:b</span><span class="p">)</span>   <span class="nv">=&gt;</span> <span class="mi">2</span>
  <span class="p">(</span><span class="ss">:c</span> <span class="nv">o</span><span class="p">)</span>       <span class="nv">=&gt;</span> <span class="mi">3</span>
  <span class="p">(</span><span class="nb">select-keys </span><span class="nv">o</span> <span class="p">[</span><span class="ss">:a</span> <span class="ss">:b</span><span class="p">])</span> <span class="nv">=&gt;</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span><span class="p">})</span>
</pre></div>
</div><div><a name="end-notes"></a><h2><b>8 &nbsp;&nbsp; End Notes</b></h2></div><div><p>For any feedback, requests and comments, please feel free to lodge an issue on github or contact me directly.</p><p>Chris.</p></div></section></body><script type="text/javascript">var metas = document.getElementsByTagName('meta');
var i;
if (navigator.userAgent.match(/iPhone/i)) {
  for (i=0; i<metas.length; i++) {
    if (metas[i].name == "viewport") {
      metas[i].content = "width=device-width, minimum-scale=1.0, maximum-scale=1.0";
    }
  }
  document.addEventListener("gesturestart", gestureStart, false);
}
function gestureStart() {
  for (i=0; i<metas.length; i++) {
    if (metas[i].name == "viewport") {
      metas[i].content = "width=device-width, minimum-scale=0.25, maximum-scale=1.6";
    }
  }
}</script><script>var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-31320512-2']);
        _gaq.push(['_trackPageview']);

        (function() {
          var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
          ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
          var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();</script></html>